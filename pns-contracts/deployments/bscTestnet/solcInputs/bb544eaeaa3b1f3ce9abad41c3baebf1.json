{
  "language": "Solidity",
  "sources": {
    "contracts/.deps/npm/@ensdomains/buffer/contracts/Buffer.sol": {
      "content": "// SPDX-License-Identifier: BSD-2-Clause\npragma solidity ^0.8.4;\n\n/**\n* @dev A library for working with mutable byte buffers in Solidity.\n*\n* Byte buffers are mutable and expandable, and provide a variety of primitives\n* for appending to them. At any time you can fetch a bytes object containing the\n* current contents of the buffer. The bytes object should not be stored between\n* operations, as it may change due to resizing of the buffer.\n*/\nlibrary Buffer {\n    /**\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n    *      a capacity. The capacity may be longer than the current value, in\n    *      which case it can be extended without the need to allocate more memory.\n    */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n    * @dev Initializes a buffer with an initial capacity.\n    * @param buf The buffer to initialize.\n    * @param capacity The number of bytes of space to allocate the buffer.\n    * @return The buffer, for chaining.\n    */\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            let fpm := add(32, add(ptr, capacity))\n            if lt(fpm, ptr) {\n                revert(0, 0)\n            }\n            mstore(0x40, fpm)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Initializes a new buffer from an existing bytes object.\n    *      Changes to the buffer may mutate the original value.\n    * @param b The bytes object to initialize the buffer with.\n    * @return A new buffer.\n    */\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    /**\n    * @dev Sets buffer length to 0.\n    * @param buf The buffer to truncate.\n    * @return The original buffer, for chaining..\n    */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\n        require(len <= data.length);\n\n        uint off = buf.buf.length;\n        uint newCapacity = off + len;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(newCapacity, buflen) {\n                mstore(bufptr, newCapacity)\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return append(buf, data, data.length);\n    }\n\n    /**\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint offPlusOne = off + 1;\n        if (off >= buf.capacity) {\n            resize(buf, offPlusOne * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if gt(offPlusOne, mload(bufptr)) {\n                mstore(bufptr, offPlusOne)\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\n    *      exceed the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to write (left-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        unchecked {\n            uint mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + newCapacity\n                let dest := add(bufptr, newCapacity)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(newCapacity, mload(bufptr)) {\n                    mstore(bufptr, newCapacity)\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chhaining.\n    */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return append(buf, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return append(buf, data, 32);\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     *      exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @param len The number of bytes to write (right-aligned).\n     * @return The original buffer.\n     */\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + newCapacity\n            let dest := add(bufptr, newCapacity)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(newCapacity, mload(bufptr)) {\n                mstore(bufptr, newCapacity)\n            }\n        }\n        return buf;\n    }\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be burned (destroyed).\n */\nabstract contract ERC721Burnable is Context, ERC721 {\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _burn(tokenId);\n    }\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/utils/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n *\n * _Available since v4.5._\n */\nlibrary Base64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // Loads the table into memory\n        string memory table = _TABLE;\n\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n        // and split into 4 numbers of 6 bits.\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n        // - `data.length + 2`  -> Round up\n        // - `/ 3`              -> Number of 3-bytes chunks\n        // - `4 *`              -> 4 characters for each chunk\n        string memory result = new string(4 * ((data.length + 2) / 3));\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 32)\n\n            // Run over the input, 3 bytes at a time\n            for {\n                let dataPtr := data\n                let endPtr := add(data, mload(data))\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 bytes (18 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F which is the number of\n                // the previous character in the ASCII table prior to the Base64 Table\n                // The result is then added to the table to get the character to write,\n                // and finally write it in the result pointer but with a left shift\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // When data `bytes` is not exactly 3 bytes long\n            // it is padded with `=` characters at the end\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n                mstore8(sub(resultPtr, 2), 0x3d)\n            }\n            case 2 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/.deps/npm/@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\n     * consuming from one or the other at each step according to the instructions given by\n     * `proofFlags`.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "contracts/activities/WENSMysteryBox.sol": {
      "content": "import \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\n\ncontract WENSMysteryBox is ERC721Enumerable, Pausable, Ownable, ERC721Holder {\n\n    enum Status {\n        Paused,\n        Preminting,\n        Started\n    }\n\n    using Strings for uint256;\n\n    event CollectionAddressAdded(address addr);\n\n    Status public status = Status.Paused;\n    bytes32 public root;\n    address[] public collections;\n\n    mapping(address => uint256) private _numberMinted;\n    mapping(uint256 => uint256) private seeds;\n\n    uint256 public MAX_MINT_PER_ADDR = 2;\n    uint256 public MAX_MINT_PER_ADDR_PUBLIC = 2;\n    string public boxURI = \"ipfs://bafkreies2ij5yltw5yjscoezjwoec73zye3zvbtrhmulftgnomvgan6otq\";\n\n    uint256 public maxSupply = 111110;\n    uint256 public allowlistSupply = 40000;\n    uint256 public price = 99000000000000000; //0.099 ETHW\n    uint256 public currentId = 1;\n    bool public canOpen;\n\n    constructor(address[] memory addrs) ERC721(\"WENS Mystery Box\", \"WENS-MBOX\") {\n        setAddressToCollection(addrs);\n    }\n\n    function numberMinted(address owner) public view returns (uint256) {\n        return _numberMinted[owner];\n    }\n\n    function allowlistClaim(uint256 quantity, bytes32[] memory _proof) public payable {\n        require(status == Status.Preminting, \"not start\");\n        require(_verify(_leaf(msg.sender), _proof), \"not in allowlist\");\n        require(currentId + quantity <= allowlistSupply, \"out of allowlist supply\");\n        require(\n            numberMinted(msg.sender) + quantity <= MAX_MINT_PER_ADDR,\n            \"exceeded\"\n        );\n        claim(quantity);\n    }\n\n    function publicClaim(uint256 quantity) public payable {\n        require(status == Status.Started, \"not start\");\n        require(\n            numberMinted(msg.sender) + quantity <= MAX_MINT_PER_ADDR_PUBLIC,\n            \"exceeded\"\n        );\n        claim(quantity);\n    }\n\n    function claim(uint256 quantity) internal {\n        require(tx.origin == msg.sender, \"contract call not allowed\");\n        require(currentId + quantity <= maxSupply, \"out of max supply\");\n        _numberMinted[msg.sender] += quantity;\n        mint(msg.sender, quantity);\n        checkPrice(price * quantity);\n    }\n\n    function open(uint256 tokenId) public {\n        require(tx.origin == msg.sender, \"contract call not allowed\");\n        require(canOpen, \"not start\");\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: caller is not token owner nor approved\");\n        uint256 seed = seeds[tokenId];\n        address nftAddress = getCollection(seed, tokenId);\n        require(nftAddress != address(0), \"no reward\");\n        IERC721Enumerable nft = IERC721Enumerable(nftAddress);\n        uint256 balance = nft.balanceOf(address(this));\n        uint256 index = (seed + block.difficulty + tokenId + block.timestamp) % balance;\n        uint256 rewardTokenId = nft.tokenOfOwnerByIndex(address(this), index);\n        nft.safeTransferFrom(\n            address(this),\n            msg.sender,\n            rewardTokenId\n        );\n        _burn(tokenId);\n    }\n\n    function mint(address to, uint256 quantity) internal {\n        for (uint256 i = 0; i < quantity; i++) {\n            uint256 tokenId = currentId + i;\n            _safeMint(to, tokenId);\n            uint256 seed = (block.timestamp + block.difficulty + block.number + tokenId * 33) % 1000;\n            seeds[tokenId] = seed;\n        }\n        currentId = currentId + quantity;\n    }\n\n    function checkPrice(uint256 cost) private {\n        require(msg.value >= cost, \"ETH is not enough\");\n\n        if (msg.value > cost) {\n            payable(msg.sender).transfer(msg.value - cost);\n        }\n    }\n\n    function getCollection(uint256 seed, uint256 tokenId) private returns (address) {\n        uint length = collections.length;\n        uint256 index = (seed + tokenId + block.timestamp) % length;\n        address collectionAddress = collections[index];\n        if (IERC721(collectionAddress).balanceOf(address(this)) > 0) {\n            return collectionAddress;\n        }\n        return getFallbackCollection();\n    }\n\n    function getFallbackCollection() private returns (address) {\n        for (uint256 i = 0; i < collections.length; i++) {\n            address collectionAddress = collections[i];\n            if (IERC721(collectionAddress).balanceOf(address(this)) > 0) {\n                return collectionAddress;\n            }\n        }\n    }\n\n    function addAddressToCollection(address addr) onlyOwner public returns (bool success) {\n        collections.push(addr);\n        emit CollectionAddressAdded(addr);\n        success = true;\n    }\n\n    function setAddressToCollection(address[] memory addrs) onlyOwner public {\n        delete collections;\n        for (uint256 i = 0; i < addrs.length; i++) {\n            addAddressToCollection(addrs[i]);\n        }\n    }\n\n    function setAmount(uint256 amount) public onlyOwner {\n        MAX_MINT_PER_ADDR = amount;\n    }\n\n    function setPublicAmount(uint256 amount) public onlyOwner {\n        MAX_MINT_PER_ADDR_PUBLIC = amount;\n    }\n\n    function setAllowlistSupply(uint256 supply) public onlyOwner {\n        require(supply < maxSupply, 'exceeded');\n        allowlistSupply = supply;\n    }\n\n    function setPrice(uint256 newPrice) public onlyOwner {\n        price = newPrice;\n    }\n\n    function setStatus(Status newStatus) public onlyOwner {\n        status = newStatus;\n    }\n\n    function setOpenStatus(bool newStatus) public onlyOwner {\n        canOpen = newStatus;\n    }\n\n    function withdraw() public payable onlyOwner {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function emergencyWithdrawNFT(address nftAddress, uint256 tokenId) public onlyOwner {\n        IERC721 nft = IERC721(nftAddress);\n        nft.safeTransferFrom(address(this), owner(), tokenId);\n    }\n\n    function tokenURI(uint256 tokenId)\n    public\n    view\n    override\n    returns (string memory)\n    {\n        string memory baseURI = _baseURI();\n        return\n            bytes(baseURI).length != 0\n                ? string(abi.encodePacked(baseURI, tokenId.toString(), \".json\"))\n                : boxURI;\n    }\n\n    function setRoot(uint256 _root) public onlyOwner {\n        root = bytes32(_root);\n    }\n\n    function _leaf(address account) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(account));\n    }\n\n    function _verify(bytes32 leaf, bytes32[] memory proof)\n    internal\n    view\n    returns (bool)\n    {\n        return MerkleProof.verify(proof, root, leaf);\n    }\n}"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\n     * consuming from one or the other at each step according to the instructions given by\n     * `proofFlags`.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be burned (destroyed).\n */\nabstract contract ERC721Burnable is Context, ERC721 {\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _burn(tokenId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/root/Root.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"../registry/PNS.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./Controllable.sol\";\n\ncontract Root is Ownable, Controllable {\n    bytes32 private constant ROOT_NODE = bytes32(0);\n\n    bytes4 private constant INTERFACE_META_ID =\n    bytes4(keccak256(\"supportsInterface(bytes4)\"));\n\n    event TLDLocked(bytes32 indexed label);\n\n    PNS public pns;\n    mapping(bytes32 => bool) public locked;\n\n    constructor(PNS _pns) public {\n        pns = _pns;\n    }\n\n    function setSubnodeOwner(bytes32 label, address owner) external onlyController {\n        require(!locked[label]);\n        pns.setSubnodeOwner(ROOT_NODE, label, owner);\n    }\n\n    function setResolver(address resolver) external onlyOwner {\n        pns.setResolver(ROOT_NODE, resolver);\n    }\n\n    function lock(bytes32 label) external onlyOwner {\n        emit TLDLocked(label);\n        locked[label] = true;\n    }\n\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool){\n        return interfaceID == INTERFACE_META_ID;\n    }\n}\n"
    },
    "contracts/registry/PNS.sol": {
      "content": "\npragma solidity >=0.8.4;\n\ninterface PNS {\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external virtual;\n\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external virtual;\n\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external virtual returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external virtual;\n\n    function setOwner(bytes32 node, address owner) external virtual;\n\n    function setTTL(bytes32 node, uint64 ttl) external virtual;\n\n    function setApprovalForAll(address operator, bool approved) external virtual;\n\n    function owner(bytes32 node) external virtual view returns (address);\n\n    function resolver(bytes32 node) external virtual view returns (address);\n\n    function ttl(bytes32 node) external virtual view returns (uint64);\n\n    function recordExists(bytes32 node) external virtual view returns (bool);\n\n    function isApprovedForAll(address owner, address operator) external virtual view returns (bool);\n}\n"
    },
    "contracts/root/Controllable.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Controllable is Ownable {\n    mapping(address => bool) public controllers;\n\n    event ControllerChanged(address indexed controller, bool enabled);\n\n    modifier onlyController {\n        require(\n            controllers[msg.sender],\n            \"Controllable: Caller is not a controller\"\n        );\n        _;\n    }\n\n    function setController(address controller, bool enabled) public onlyOwner {\n        controllers[controller] = enabled;\n        emit ControllerChanged(controller, enabled);\n    }\n}\n"
    },
    "contracts/registry/ReverseRegistrar.sol": {
      "content": "pragma solidity >=0.8.4;\n\nimport \"./PNS.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../root/Controllable.sol\";\n\nabstract contract NameResolver {\n    function setName(bytes32 node, string memory name) public virtual;\n}\n\nbytes32 constant lookup = 0x3031323334353637383961626364656600000000000000000000000000000000;\n\nbytes32 constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n\n// namehash('addr.reverse')\n\ncontract ReverseRegistrar is Ownable, Controllable {\n    PNS public pns;\n    NameResolver public defaultResolver;\n\n    event ReverseClaimed(address indexed addr, bytes32 indexed node);\n\n    /**\n     * @dev Constructor\n     * @param pnsAddr The address of the WPNS registry.\n     * @param resolverAddr The address of the default reverse resolver.\n     */\n    constructor(PNS pnsAddr, NameResolver resolverAddr) {\n        pns = pnsAddr;\n        defaultResolver = resolverAddr;\n\n        // Assign ownership of the reverse record to our deployer\n        ReverseRegistrar oldRegistrar = ReverseRegistrar(\n            pns.owner(ADDR_REVERSE_NODE)\n        );\n        if (address(oldRegistrar) != address(0x0)) {\n            oldRegistrar.claim(msg.sender);\n        }\n    }\n\n    modifier authorised(address addr) {\n        require(\n            addr == msg.sender ||\n            controllers[msg.sender] ||\n            pns.isApprovedForAll(addr, msg.sender) ||\n            ownsContract(addr),\n            \"Caller is not a controller or authorised by address or the address itself\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse PNS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in PNS.\n     * @return The PNS node hash of the reverse record.\n     */\n    function claim(address owner) public returns (bytes32) {\n        return _claimWithResolver(msg.sender, owner, address(0x0));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse PNS record associated with the\n     *      calling account.\n     * @param addr The reverse record to set\n     * @param owner The address to set as the owner of the reverse record in PNS.\n     * @return The PNS node hash of the reverse record.\n     */\n    function claimForAddr(address addr, address owner) public authorised(addr) returns (bytes32){\n        return _claimWithResolver(addr, owner, address(0x0));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse PNS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in PNS.\n     * @param resolver The address of the resolver to set; 0 to leave unchanged.\n     * @return The PNS node hash of the reverse record.\n     */\n    function claimWithResolver(address owner, address resolver) public returns (bytes32){\n        return _claimWithResolver(msg.sender, owner, resolver);\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse PNS record specified with the\n     *      address provided\n     * @param addr The reverse record to set\n     * @param owner The address to set as the owner of the reverse record in PNS.\n     * @param resolver The address of the resolver to set; 0 to leave unchanged.\n     * @return The PNS node hash of the reverse record.\n     */\n    function claimWithResolverForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) public authorised(addr) returns (bytes32) {\n        return _claimWithResolver(addr, owner, resolver);\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse PNS record associated with\n     * the calling account. First updates the resolver to the default reverse\n     * resolver if necessary.\n     * @param name The name to set for this address.\n     * @return The PNS node hash of the reverse record.\n     */\n    function setName(string memory name) public returns (bytes32) {\n        bytes32 node = _claimWithResolver(\n            msg.sender,\n            address(this),\n            address(defaultResolver)\n        );\n        defaultResolver.setName(node, name);\n        return node;\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse PNS record associated with\n     * the account provided. First updates the resolver to the default reverse\n     * resolver if necessary.\n     * Only callable by controllers and authorised users\n     * @param addr The reverse record to set\n     * @param owner The owner of the reverse node\n     * @param name The name to set for this address.\n     * @return The PNS node hash of the reverse record.\n     */\n    function setNameForAddr(\n        address addr,\n        address owner,\n        string memory name\n    ) public authorised(addr) returns (bytes32) {\n        bytes32 node = _claimWithResolver(\n            addr,\n            address(this),\n            address(defaultResolver)\n        );\n        defaultResolver.setName(node, name);\n        pns.setSubnodeOwner(ADDR_REVERSE_NODE, sha3HexAddress(addr), owner);\n        return node;\n    }\n\n    /**\n     * @dev Returns the node hash for a given account's reverse records.\n     * @param addr The address to hash\n     * @return The PNS node hash.\n     */\n    function node(address addr) public pure returns (bytes32) {\n        return\n        keccak256(\n            abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr))\n        );\n    }\n\n    /**\n     * @dev An optimised function to compute the sha3 of the lower-case\n     *      hexadecimal representation of an Ethereum address.\n     * @param addr The address to hash\n     * @return ret The SHA3 hash of the lower-case hexadecimal encoding of the\n     *         input address.\n     */\n    function sha3HexAddress(address addr) private pure returns (bytes32 ret) {\n        assembly {\n            for {\n                let i := 40\n            } gt(i, 0) {\n\n            } {\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n            }\n\n            ret := keccak256(0, 40)\n        }\n    }\n\n    /* Internal functions */\n\n    function _claimWithResolver(\n        address addr,\n        address owner,\n        address resolver\n    ) internal returns (bytes32) {\n        bytes32 label = sha3HexAddress(addr);\n        bytes32 node = keccak256(abi.encodePacked(ADDR_REVERSE_NODE, label));\n        address currentResolver = pns.resolver(node);\n        bool shouldUpdateResolver = (resolver != address(0x0) &&\n            resolver != currentResolver);\n        address newResolver = shouldUpdateResolver ? resolver : currentResolver;\n\n        pns.setSubnodeRecord(ADDR_REVERSE_NODE, label, owner, newResolver, 0);\n\n        emit ReverseClaimed(addr, node);\n\n        return node;\n    }\n\n    function ownsContract(address addr) internal view returns (bool) {\n        try Ownable(addr).owner() returns (address owner) {\n            return owner == msg.sender;\n        } catch {\n            return false;\n        }\n    }\n}\n"
    },
    "contracts/resolvers/DefaultReverseResolver.sol": {
      "content": "pragma solidity >=0.8.4;\n\nimport \"../registry/PNS.sol\";\nimport \"../registry/ReverseRegistrar.sol\";\n\n/**\n * @dev Provides a default implementation of a resolver for reverse records,\n * which permits only the owner to update it.\n */\ncontract DefaultReverseResolver {\n    // namehash('addr.reverse')\n    bytes32 constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n\n    PNS public pns;\n    mapping(bytes32 => string) public name;\n\n    /**\n     * @dev Only permits calls by the reverse registrar.\n     * @param node The node permission is required for.\n     */\n    modifier onlyOwner(bytes32 node) {\n        require(msg.sender == pns.owner(node));\n        _;\n    }\n\n    /**\n     * @dev Constructor\n     * @param pnsAddr The address of the WPNS registry.\n     */\n    constructor(PNS pnsAddr) {\n        pns = pnsAddr;\n\n        // Assign ownership of the reverse record to our deployer\n        ReverseRegistrar registrar = ReverseRegistrar(pns.owner(ADDR_REVERSE_NODE));\n        if (address(registrar) != address(0x0)) {\n            registrar.claim(msg.sender);\n        }\n    }\n\n    /**\n     * @dev Sets the name for a node.\n     * @param node The node to update.\n     * @param _name The name to set.\n     */\n    function setName(bytes32 node, string memory _name) public onlyOwner(node) {\n        name[node] = _name;\n    }\n}\n"
    },
    "contracts/resolvers/PublicResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../registry/PNS.sol\";\nimport \"./profiles/ABIResolver.sol\";\nimport \"./profiles/AddrResolver.sol\";\nimport \"./profiles/ContentHashResolver.sol\";\nimport \"./profiles/InterfaceResolver.sol\";\nimport \"./profiles/NameResolver.sol\";\nimport \"./profiles/PubkeyResolver.sol\";\nimport \"./profiles/TextResolver.sol\";\nimport \"./Multicallable.sol\";\n\n\n/**\n * A simple resolver anyone can use; only allows the owner of a node to set its\n * address.\n */\ncontract PublicResolver is Multicallable, ABIResolver, AddrResolver, ContentHashResolver, InterfaceResolver, NameResolver, PubkeyResolver, TextResolver {\n    PNS pns;\n    /**\n     * A mapping of operators. An address that is authorised for an address\n     * may make any changes to the name that the owner could, but may not update\n     * the set of authorisations.\n     * (owner, operator) => approved\n     */\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    constructor(PNS _pns){\n        pns = _pns;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) external{\n        require(\n            msg.sender != operator,\n            \"ERC1155: setting approval status for self\"\n        );\n\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function isAuthorised(bytes32 node) internal override view returns(bool) {\n        address owner = pns.owner(node);\n        return owner == msg.sender || isApprovedForAll(owner, msg.sender);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view returns (bool){\n        return _operatorApprovals[account][operator];\n    }\n\n    function supportsInterface(bytes4 interfaceID) public override(Multicallable, ABIResolver, AddrResolver, ContentHashResolver, InterfaceResolver, NameResolver, PubkeyResolver, TextResolver) pure returns(bool) {\n        return interfaceID == type(IMulticallable).interfaceId || super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/resolvers/profiles/ABIResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"./IABIResolver.sol\";\nimport \"../ResolverBase.sol\";\n\nabstract contract ABIResolver is IABIResolver, ResolverBase {\n    mapping(bytes32 => mapping(uint256 => bytes)) abis;\n\n    /**\n     * Sets the ABI associated with an ENS node.\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\n     * the empty string.\n     * @param node The node to update.\n     * @param contentType The content type of the ABI\n     * @param data The ABI data.\n     */\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) virtual external authorised(node) {\n        // Content types must be powers of 2\n        require(((contentType - 1) & contentType) == 0);\n\n        abis[node][contentType] = data;\n        emit ABIChanged(node, contentType);\n    }\n\n    /**\n     * Returns the ABI associated with an ENS node.\n     * Defined in EIP205.\n     * @param node The ENS node to query\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\n     * @return contentType The content type of the return value\n     * @return data The ABI data\n     */\n    function ABI(bytes32 node, uint256 contentTypes) virtual override external view returns (uint256, bytes memory) {\n        mapping(uint256 => bytes) storage abiset = abis[node];\n\n        for (uint256 contentType = 1; contentType <= contentTypes; contentType <<= 1) {\n            if ((contentType & contentTypes) != 0 && abiset[contentType].length > 0) {\n                return (contentType, abiset[contentType]);\n            }\n        }\n\n        return (0, bytes(\"\"));\n    }\n\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns (bool) {\n        return interfaceID == type(IABIResolver).interfaceId || super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/resolvers/profiles/AddrResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../ResolverBase.sol\";\nimport \"./IAddrResolver.sol\";\nimport \"./IAddressResolver.sol\";\n\nabstract contract AddrResolver is IAddrResolver, IAddressResolver, ResolverBase {\n    uint constant private COIN_TYPE_ETH = 60;\n\n    mapping(bytes32 => mapping(uint => bytes)) _addresses;\n\n    /**\n     * Sets the address associated with an ENS node.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param a The address to set.\n     */\n    function setAddr(bytes32 node, address a) virtual external authorised(node) {\n        setAddr(node, COIN_TYPE_ETH, addressToBytes(a));\n    }\n\n    /**\n     * Returns the address associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated address.\n     */\n    function addr(bytes32 node) virtual override public view returns (address payable) {\n        bytes memory a = addr(node, COIN_TYPE_ETH);\n        if (a.length == 0) {\n            return payable(0);\n        }\n        return bytesToAddress(a);\n    }\n\n    function setAddr(bytes32 node, uint coinType, bytes memory a) virtual public authorised(node) {\n        emit AddressChanged(node, coinType, a);\n        if (coinType == COIN_TYPE_ETH) {\n            emit AddrChanged(node, bytesToAddress(a));\n        }\n        _addresses[node][coinType] = a;\n    }\n\n    function addr(bytes32 node, uint coinType) virtual override public view returns (bytes memory) {\n        return _addresses[node][coinType];\n    }\n\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns (bool) {\n        return interfaceID == type(IAddrResolver).interfaceId || interfaceID == type(IAddressResolver).interfaceId || super.supportsInterface(interfaceID);\n    }\n\n    function bytesToAddress(bytes memory b) internal pure returns (address payable a) {\n        require(b.length == 20);\n        assembly {\n            a := div(mload(add(b, 32)), exp(256, 12))\n        }\n    }\n\n    function addressToBytes(address a) internal pure returns (bytes memory b) {\n        b = new bytes(20);\n        assembly {\n            mstore(add(b, 32), mul(a, exp(256, 12)))\n        }\n    }\n}\n"
    },
    "contracts/resolvers/profiles/ContentHashResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../ResolverBase.sol\";\nimport \"./IContentHashResolver.sol\";\n\nabstract contract ContentHashResolver is IContentHashResolver, ResolverBase {\n    mapping(bytes32 => bytes) hashes;\n\n    /**\n     * Sets the contenthash associated with an ENS node.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param hash The contenthash to set\n     */\n    function setContenthash(bytes32 node, bytes calldata hash) virtual external authorised(node) {\n        hashes[node] = hash;\n        emit ContenthashChanged(node, hash);\n    }\n\n    /**\n     * Returns the contenthash associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated contenthash.\n     */\n    function contenthash(bytes32 node) virtual external override view returns (bytes memory) {\n        return hashes[node];\n    }\n\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns (bool) {\n        return interfaceID == type(IContentHashResolver).interfaceId || super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/resolvers/profiles/InterfaceResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../ResolverBase.sol\";\nimport \"../ISupportsInterface.sol\";\nimport \"./AddrResolver.sol\";\nimport \"./IInterfaceResolver.sol\";\n\nabstract contract InterfaceResolver is IInterfaceResolver, AddrResolver {\n    mapping(bytes32 => mapping(bytes4 => address)) interfaces;\n\n    /**\n     * Sets an interface associated with a name.\n     * Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support.\n     * @param node The node to update.\n     * @param interfaceID The EIP 165 interface ID.\n     * @param implementer The address of a contract that implements this interface for this node.\n     */\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) virtual external authorised(node) {\n        interfaces[node][interfaceID] = implementer;\n        emit InterfaceChanged(node, interfaceID, implementer);\n    }\n\n    /**\n     * Returns the address of a contract that implements the specified interface for this name.\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\n     * contract implements EIP165 and returns `true` for the specified interfaceID, its address\n     * will be returned.\n     * @param node The PNS node to query.\n     * @param interfaceID The EIP 165 interface ID to check for.\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\n     */\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) virtual override external view returns (address) {\n        address implementer = interfaces[node][interfaceID];\n        if (implementer != address(0)) {\n            return implementer;\n        }\n\n        address a = addr(node);\n        if (a == address(0)) {\n            return address(0);\n        }\n\n        (bool success, bytes memory returnData) = a.staticcall(abi.encodeWithSignature(\"supportsInterface(bytes4)\", type(ISupportsInterface).interfaceId));\n        if (!success || returnData.length < 32 || returnData[31] == 0) {\n            // EIP 165 not supported by target\n            return address(0);\n        }\n\n        (success, returnData) = a.staticcall(abi.encodeWithSignature(\"supportsInterface(bytes4)\", interfaceID));\n        if (!success || returnData.length < 32 || returnData[31] == 0) {\n            // Specified interface not supported by target\n            return address(0);\n        }\n\n        return a;\n    }\n\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns (bool) {\n        return interfaceID == type(IInterfaceResolver).interfaceId || super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/resolvers/profiles/NameResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../ResolverBase.sol\";\nimport \"./INameResolver.sol\";\n\nabstract contract NameResolver is INameResolver, ResolverBase {\n    mapping(bytes32 => string) names;\n\n    /**\n     * Sets the name associated with an PNS node, for reverse records.\n     * May only be called by the owner of that node in the PNS registry.\n     * @param node The node to update.\n     */\n    function setName(bytes32 node, string calldata newName) virtual external authorised(node) {\n        names[node] = newName;\n        emit NameChanged(node, newName);\n    }\n\n    /**\n     * Returns the name associated with an PNS node, for reverse records.\n     * Defined in EIP181.\n     * @param node The PNS node to query.\n     * @return The associated name.\n     */\n    function name(bytes32 node) virtual override external view returns (string memory) {\n        return names[node];\n    }\n\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns (bool) {\n        return interfaceID == type(INameResolver).interfaceId || super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/resolvers/profiles/PubkeyResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../ResolverBase.sol\";\nimport \"./IPubkeyResolver.sol\";\n\nabstract contract PubkeyResolver is IPubkeyResolver, ResolverBase {\n    struct PublicKey {\n        bytes32 x;\n        bytes32 y;\n    }\n\n    mapping(bytes32 => PublicKey) pubkeys;\n\n    /**\n     * Sets the SECP256k1 public key associated with an PNS node.\n     * @param node The PNS node to query\n     * @param x the X coordinate of the curve point for the public key.\n     * @param y the Y coordinate of the curve point for the public key.\n     */\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) virtual external authorised(node) {\n        pubkeys[node] = PublicKey(x, y);\n        emit PubkeyChanged(node, x, y);\n    }\n\n    /**\n     * Returns the SECP256k1 public key associated with an PNS node.\n     * Defined in EIP 619.\n     * @param node The PNS node to query\n     * @return x The X coordinate of the curve point for the public key.\n     * @return y The Y coordinate of the curve point for the public key.\n     */\n    function pubkey(bytes32 node) virtual override external view returns (bytes32 x, bytes32 y) {\n        return (pubkeys[node].x, pubkeys[node].y);\n    }\n\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns (bool) {\n        return interfaceID == type(IPubkeyResolver).interfaceId || super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/resolvers/profiles/TextResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../ResolverBase.sol\";\nimport \"./ITextResolver.sol\";\n\nabstract contract TextResolver is ITextResolver, ResolverBase {\n    mapping(bytes32 => mapping(string => string)) texts;\n\n    /**\n     * Sets the text data associated with an PNS node and key.\n     * May only be called by the owner of that node in the PNS registry.\n     * @param node The node to update.\n     * @param key The key to set.\n     * @param value The text data value to set.\n     */\n    function setText(bytes32 node, string calldata key, string calldata value) virtual external authorised(node) {\n        texts[node][key] = value;\n        emit TextChanged(node, key, key);\n    }\n\n    /**\n     * Returns the text data associated with an PNS node and key.\n     * @param node The PNS node to query.\n     * @param key The text data key to query.\n     * @return The associated text data.\n     */\n    function text(bytes32 node, string calldata key) virtual override external view returns (string memory) {\n        return texts[node][key];\n    }\n\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns (bool) {\n        return interfaceID == type(ITextResolver).interfaceId || super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/resolvers/Multicallable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./IMulticallable.sol\";\nimport \"./SupportsInterface.sol\";\n\nabstract contract Multicallable is IMulticallable, SupportsInterface {\n    function multicall(bytes[] calldata data) external override returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n            require(success);\n            results[i] = result;\n        }\n        return results;\n    }\n\n    function supportsInterface(bytes4 interfaceID) public override virtual pure returns (bool) {\n        return interfaceID == type(IMulticallable).interfaceId || super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/resolvers/profiles/IABIResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"./IABIResolver.sol\";\nimport \"../ResolverBase.sol\";\n\ninterface IABIResolver {\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\n    /**\n     * Returns the ABI associated with an ENS node.\n     * Defined in EIP205.\n     * @param node The ENS node to query\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\n     * @return contentType The content type of the return value\n     * @return data The ABI data\n     */\n    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory);\n}\n"
    },
    "contracts/resolvers/ResolverBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"./SupportsInterface.sol\";\n\nabstract contract ResolverBase is SupportsInterface {\n    function isAuthorised(bytes32 node) internal virtual view returns (bool);\n\n    modifier authorised(bytes32 node) {\n        require(isAuthorised(node), \"is not authorised\");\n        _;\n    }\n}\n"
    },
    "contracts/resolvers/SupportsInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ISupportsInterface.sol\";\n\nabstract contract SupportsInterface is ISupportsInterface {\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns (bool) {\n        return interfaceID == type(ISupportsInterface).interfaceId;\n    }\n}\n"
    },
    "contracts/resolvers/ISupportsInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface ISupportsInterface {\n    function supportsInterface(bytes4 interfaceID) external pure returns(bool);\n}"
    },
    "contracts/resolvers/profiles/IAddrResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/**\n * Interface for the legacy (ETH-only) addr function.\n */\ninterface IAddrResolver {\n    event AddrChanged(bytes32 indexed node, address a);\n\n    /**\n     * Returns the address associated with an ENS node.\n     * @param node The PNS node to query.\n     * @return The associated address.\n     */\n    function addr(bytes32 node) external view returns (address payable);\n}\n"
    },
    "contracts/resolvers/profiles/IAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/**\n * Interface for the new (multicoin) addr function.\n */\ninterface IAddressResolver {\n    event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);\n\n    function addr(bytes32 node, uint coinType) external view returns (bytes memory);\n}\n"
    },
    "contracts/resolvers/profiles/IContentHashResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IContentHashResolver {\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\n\n    /**\n     * Returns the contenthash associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated contenthash.\n     */\n    function contenthash(bytes32 node) external view returns (bytes memory);\n}\n"
    },
    "contracts/resolvers/profiles/IInterfaceResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IInterfaceResolver {\n    event InterfaceChanged(bytes32 indexed node, bytes4 indexed interfaceID, address implementer);\n\n    /**\n     * Returns the address of a contract that implements the specified interface for this name.\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\n     * contract implements EIP165 and returns `true` for the specified interfaceID, its address\n     * will be returned.\n     * @param node The ENS node to query.\n     * @param interfaceID The EIP 165 interface ID to check for.\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\n     */\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address);\n}\n"
    },
    "contracts/resolvers/profiles/INameResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface INameResolver {\n    event NameChanged(bytes32 indexed node, string name);\n\n    /**\n     * Returns the name associated with an ENS node, for reverse records.\n     * Defined in EIP181.\n     * @param node The PNS node to query.\n     * @return The associated name.\n     */\n    function name(bytes32 node) external view returns (string memory);\n}\n"
    },
    "contracts/resolvers/profiles/IPubkeyResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IPubkeyResolver {\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\n\n    /**\n     * Returns the SECP256k1 public key associated with an PNS node.\n     * Defined in EIP 619.\n     * @param node The PNS node to query\n     * @return x The X coordinate of the curve point for the public key.\n     * @return y The Y coordinate of the curve point for the public key.\n     */\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\n}\n"
    },
    "contracts/resolvers/profiles/ITextResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface ITextResolver {\n    event TextChanged(bytes32 indexed node, string indexed indexedKey, string key);\n\n    /**\n     * Returns the text data associated with an ENS node and key.\n     * @param node The ENS node to query.\n     * @param key The text data key to query.\n     * @return The associated text data.\n     */\n    function text(bytes32 node, string calldata key) external view returns (string memory);\n}\n"
    },
    "contracts/resolvers/IMulticallable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IMulticallable {\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results);\n}\n"
    },
    "contracts/resolvers/Resolver.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"./profiles/IABIResolver.sol\";\nimport \"./profiles/IAddressResolver.sol\";\nimport \"./profiles/IAddrResolver.sol\";\nimport \"./profiles/IContentHashResolver.sol\";\nimport \"./profiles/IInterfaceResolver.sol\";\nimport \"./profiles/INameResolver.sol\";\nimport \"./profiles/IPubkeyResolver.sol\";\nimport \"./profiles/ITextResolver.sol\";\nimport \"./ISupportsInterface.sol\";\n/**\n * A generic resolver interface which includes all the functions including the ones deprecated\n */\ninterface Resolver is ISupportsInterface, IABIResolver, IAddressResolver, IAddrResolver, IContentHashResolver, IInterfaceResolver, INameResolver, IPubkeyResolver, ITextResolver {\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external;\n\n    function setAddr(bytes32 node, address addr) external;\n\n    function setAddr(bytes32 node, uint coinType, bytes calldata a) external;\n\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n\n    function setName(bytes32 node, string calldata _name) external;\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n\n    function setText(bytes32 node, string calldata key, string calldata value) external;\n\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external;\n\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n\n    function multihash(bytes32 node) external view returns (bytes memory);\n\n    function setContent(bytes32 node, bytes32 hash) external;\n\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}\n"
    },
    "contracts/resolvers/OwnedResolver.sol": {
      "content": "pragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./profiles/ABIResolver.sol\";\nimport \"./profiles/AddrResolver.sol\";\nimport \"./profiles/ContentHashResolver.sol\";\nimport \"./profiles/InterfaceResolver.sol\";\nimport \"./profiles/NameResolver.sol\";\nimport \"./profiles/PubkeyResolver.sol\";\nimport \"./profiles/TextResolver.sol\";\n\n/**\n * A simple resolver anyone can use; only allows the owner of a node to set its\n * address.\n */\ncontract OwnedResolver is Ownable, ABIResolver, AddrResolver, ContentHashResolver, InterfaceResolver, NameResolver, PubkeyResolver, TextResolver {\n    function isAuthorised(bytes32) internal override view returns (bool) {\n        return msg.sender == owner();\n    }\n\n    function supportsInterface(bytes4 interfaceID) virtual override(ABIResolver, AddrResolver, ContentHashResolver, InterfaceResolver, NameResolver, PubkeyResolver, TextResolver) public pure returns (bool) {\n        return super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/registrar/BulkRenewal.sol": {
      "content": "pragma solidity >=0.8.4;\npragma experimental ABIEncoderV2;\n\nimport \"../registry/PNS.sol\";\nimport \"./RegistrarController.sol\";\nimport \"../resolvers/Resolver.sol\";\n\ncontract BulkRenewal {\n    bytes32 constant private ETH_NAMEHASH = 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    bytes4 constant private REGISTRAR_CONTROLLER_ID = 0x018fac06;\n    bytes4 constant private INTERFACE_META_ID = bytes4(keccak256(\"supportsInterface(bytes4)\"));\n    bytes4 constant public BULK_RENEWAL_ID = bytes4(\n        keccak256(\"rentPrice(string[],uint)\") ^\n        keccak256(\"renewAll(string[],uint\")\n    );\n\n    PNS public pns;\n\n    constructor(PNS _pns) public {\n        pns = _pns;\n    }\n\n    function getController() internal view returns (RegistrarController) {\n        Resolver r = Resolver(pns.resolver(ETH_NAMEHASH));\n        return RegistrarController(r.interfaceImplementer(ETH_NAMEHASH, REGISTRAR_CONTROLLER_ID));\n    }\n\n    function rentPrice(string[] calldata names, uint duration) external view returns (uint total) {\n        RegistrarController controller = getController();\n        for (uint i = 0; i < names.length; i++) {\n            total += controller.rentPrice(names[i], duration);\n        }\n    }\n\n    function renewAll(string[] calldata names, uint duration) external payable {\n        RegistrarController controller = getController();\n        for (uint i = 0; i < names.length; i++) {\n            uint cost = controller.rentPrice(names[i], duration);\n            controller.renew{value: cost}(names[i], duration);\n        }\n        // Send any excess funds back\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\n        return interfaceID == INTERFACE_META_ID || interfaceID == BULK_RENEWAL_ID;\n    }\n}\n"
    },
    "contracts/registrar/RegistrarController.sol": {
      "content": "pragma solidity >=0.8.12;\n\nimport \"./BaseRegistrarImplementation.sol\";\nimport \"./StringUtils.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./Whitelist.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\n\n/**\n * @dev A registrar controller for registering and renewing names at fixed cost.\n */\ncontract RegistrarController is Ownable {\n    using StringUtils for *;\n\n    uint256 public constant MIN_REGISTRATION_DURATION = 365 days;\n\n    BaseRegistrarImplementation base;\n    uint256 public mintPerWallet = 100;\n    mapping(address => uint256) public mintCount;\n    constructor (\n        BaseRegistrarImplementation _base,\n        uint _basePrice,\n        uint256 _minCommitmentAge,\n        uint256 _maxCommitmentAge\n    ) {\n        base = _base;\n        basePrice = _basePrice;\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n    }\n\n    uint public basePrice;\n\n    uint256 public minCommitmentAge;\n    uint256 public maxCommitmentAge;\n    mapping(bytes32 => uint256) public commitments;\n\n    event NameRegistered(\n        string name,\n        bytes32 indexed label,\n        address indexed owner,\n        uint256 cost,\n        uint256 expires\n    );\n    event NameRenewed(\n        string name,\n        bytes32 indexed label,\n        uint256 cost,\n        uint256 expires\n    );\n\n    bytes32 public root;\n\n    function setMintPerWallet(uint256 _mintPerWallet) public onlyOwner {\n        mintPerWallet = _mintPerWallet;\n    }\n\n    function makeCommitment(\n        string memory name,\n        address owner,\n        bytes32 secret,\n        address resolver\n    ) public pure returns (bytes32) {\n        bytes32 label = keccak256(bytes(name));\n        require(resolver != address(0), \"resolver invalid\");\n        return\n        keccak256(\n            abi.encodePacked(label, owner, resolver, secret)\n        );\n    }\n\n    function commit(bytes32 commitment) public {\n        require(commitments[commitment] + maxCommitmentAge < block.timestamp);\n        commitments[commitment] = block.timestamp;\n    }\n\n    function register(\n        string memory name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver\n    ) public payable {\n        require(mintCount[owner] < mintPerWallet, \"exceed max mint\");\n\n        bytes32 commitment = makeCommitment(\n            name,\n            owner,\n            secret,\n            resolver\n        );\n        uint256 cost = _consumeCommitment(name, duration, commitment);\n\n        bytes32 label = keccak256(bytes(name));\n        uint256 tokenId = uint256(label);\n\n        _registerSingleDomain(\n            name, owner, duration, resolver, tokenId,\n            label, cost, base\n        );\n\n        // Refund any extra payment\n        if (msg.value > cost) {\n            payable(msg.sender).transfer(msg.value - cost);\n        }\n        mintCount[owner] += 1;\n    }\n\n    function _registerSingleDomain(\n        string memory name,\n        address owner,\n        uint256 duration,\n        address resolver,\n        uint tokenId,\n        bytes32 label,\n        uint cost,\n        BaseRegistrarImplementation registrar\n    ) internal {\n        // The nodehash of this label\n        bytes32 nodehash = keccak256(abi.encodePacked(registrar.baseNode(), label));\n\n        // Set this contract as the (temporary) owner, giving it\n        uint256 expires;\n        // permission to set up the resolver.\n        expires = registrar.register(tokenId, address(this), duration);\n\n        // Set the resolver\n        registrar.pns().setResolver(nodehash, resolver);\n\n        // Configure the resolver\n        Resolver(resolver).setAddr(nodehash, owner);\n        Resolver(resolver).setName(nodehash, name);\n\n        // Now transfer full ownership to the expeceted owner\n        registrar.reclaim(tokenId, owner);\n        registrar.transferFrom(address(this), owner, tokenId);\n        emit NameRegistered(name, label, owner, cost, expires);\n    }\n\n    function renew(\n        string calldata name,\n        uint256 duration\n    ) external payable {\n        uint256 cost = rentPrice(name, duration);\n        require(msg.value >= cost);\n\n        bytes32 label = keccak256(bytes(name));\n        uint256 expires = base.renew(uint256(label), duration);\n        emit NameRenewed(name, label, cost, expires);\n\n        if (msg.value > cost) {\n            payable(msg.sender).transfer(msg.value - cost);\n        }\n    }\n\n    function setCommitmentAges(\n        uint256 _minCommitmentAge,\n        uint256 _maxCommitmentAge\n    ) public onlyOwner {\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n    }\n\n    function withdraw() public onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function _consumeCommitment(\n        string memory name,\n        uint256 duration,\n        bytes32 commitment\n    ) internal returns (uint256) {\n        // Require a valid commitment\n        require(\n            commitments[commitment] + minCommitmentAge <= block.timestamp,\n            \"invalid with minCommitmentAge\"\n        );\n\n        // If the commitment is too old, or the name is registered, stop\n        require(\n            commitments[commitment] + maxCommitmentAge > block.timestamp,\n            \"invalid with maxCommitmentAge\"\n        );\n        require(available(name), \"name not available\");\n\n        delete (commitments[commitment]);\n\n        uint256 cost = rentPrice(name, duration);\n        require(\n            duration >= MIN_REGISTRATION_DURATION,\n            \"Duration should be greater than 365 days\"\n        );\n        require(msg.value >= cost, \"invalid pay\");\n\n        return cost;\n    }\n\n    function setBasePrice(uint _price) public onlyOwner {\n        basePrice = _price;\n    }\n\n    function rentPrice(\n        string memory name,\n        uint256 duration\n    ) public view returns (uint256){\n        // no need to check basePrice\n        // require(basePrice > 0, \"configuration incorrect\");\n        uint price = basePrice * duration;\n        return price;\n    }\n\n    function valid(string memory name) public view returns (bool) {\n        if (name.strlen() < 1) {\n            return false;\n        }\n        bytes memory nb = bytes(name);\n        // zero width for /u200b /u200c /u200d and U+FEFF\n\n        for (uint256 i; i < nb.length; i++) {\n            bytes1 char = nb[i];\n            if (char >= 0x41 && char <= 0x5A) {\n                return false; //A-Z\n            }\n        }\n        // zero width\n        if (nb.length >= 2) {\n            for (uint256 i; i < nb.length - 2; i++) {\n                if (bytes1(nb[i]) == 0xe2 && bytes1(nb[i + 1]) == 0x80) {\n                    if (\n                        bytes1(nb[i + 2]) == 0x8b ||\n                        bytes1(nb[i + 2]) == 0x8c ||\n                        bytes1(nb[i + 2]) == 0x8d\n                    ) {\n                        return false;\n                    }\n                } else if (bytes1(nb[i]) == 0xef) {\n                    if (bytes1(nb[i + 1]) == 0xbb && bytes1(nb[i + 2]) == 0xbf)\n                        return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    function available(string memory name) public view returns (bool) {\n        bytes32 label = keccak256(bytes(name));\n        bool _available = true;\n        if (!base.available(uint256(label))) {\n            _available = false;\n        }\n        return valid(name) && _available;\n    }\n\n    function withdraw(address receiver) public onlyOwner {\n        payable(receiver).transfer(address(this).balance);\n    }\n}\n"
    },
    "contracts/registrar/BaseRegistrarImplementation.sol": {
      "content": "pragma solidity >=0.8.4;\n\nimport \"../registry/PNS.sol\";\nimport \"../resolvers/Resolver.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"./BaseRegistrar.sol\";\nimport \"./StringUtils.sol\";\nimport \"./BaseRegistrar.sol\";\n\n\ncontract BaseRegistrarImplementation is ERC721, ERC721Enumerable, BaseRegistrar {\n    // A map of expiry times\n    mapping(uint256 => uint) expiries;\n\n    bytes4 constant private INTERFACE_META_ID = bytes4(keccak256(\"supportsInterface(bytes4)\"));\n    bytes4 constant private ERC721_ID = bytes4(\n        keccak256(\"balanceOf(address)\") ^\n        keccak256(\"ownerOf(uint256)\") ^\n        keccak256(\"approve(address,uint256)\") ^\n        keccak256(\"getApproved(uint256)\") ^\n        keccak256(\"setApprovalForAll(address,bool)\") ^\n        keccak256(\"isApprovedForAll(address,address)\") ^\n        keccak256(\"transferFrom(address,address,uint256)\") ^\n        keccak256(\"safeTransferFrom(address,address,uint256)\") ^\n        keccak256(\"safeTransferFrom(address,address,uint256,bytes)\")\n    );\n    bytes4 constant private RECLAIM_ID = bytes4(keccak256(\"reclaim(uint256,address)\"));\n    string public baseUri;\n    string public baseName;\n\n    /**\n     * v2.1.3 version of _isApprovedOrOwner which calls ownerOf(tokenId) and takes grace period into consideration instead of ERC721.ownerOf(tokenId);\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.1.3/contracts/token/ERC721/ERC721.sol#L187\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view override returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    constructor(string memory _name, string memory _symbol, PNS _pns, bytes32 _baseNode, string memory _baseName) ERC721(_name, _symbol) {\n        pns = _pns;\n        baseNode = _baseNode;\n        baseName = _baseName;\n    }\n\n    modifier live {\n        require(pns.owner(baseNode) == address(this));\n        _;\n    }\n\n    modifier onlyController {\n        require(controllers[msg.sender]);\n        _;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override(ERC721, ERC721Enumerable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public onlyController override(ERC721, IERC721) {\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            \"ERC721: caller is not approved or owner\"\n        );\n\n        _transfer(from, to, tokenId);\n        pns.setSubnodeOwner(baseNode, bytes32(tokenId), to);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public onlyController override(ERC721, IERC721) {\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            \"ERC721: caller is not approved or owner\"\n        );\n        _safeTransfer(from, to, tokenId, _data);\n        pns.setSubnodeOwner(baseNode, bytes32(tokenId), to);\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID. Names become unowned\n     *      when their registration expires.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view override(IERC721, ERC721) returns (address) {\n        require(expiries[tokenId] > block.timestamp);\n        return super.ownerOf(tokenId);\n    }\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external override onlyOwner {\n        controllers[controller] = true;\n        emit ControllerAdded(controller);\n    }\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external override onlyOwner {\n        controllers[controller] = false;\n        emit ControllerRemoved(controller);\n    }\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external override onlyOwner {\n        pns.setResolver(baseNode, resolver);\n    }\n\n    // Returns the expiration timestamp of the specified id.\n    function nameExpires(uint256 id) external view override returns (uint) {\n        return expiries[id];\n    }\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) public view override returns (bool) {\n        // Not available if it's registered here or in its grace period.\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\n    }\n\n    /**\n     * @dev Register a name.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function register(uint256 id, address owner, uint duration) external override returns (uint) {\n        return _register(id, owner, duration, true);\n    }\n\n    /**\n     * @dev Register a name, without modifying the registry.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function registerOnly(uint256 id, address owner, uint duration) external returns (uint) {\n        return _register(id, owner, duration, false);\n    }\n\n    function _register(uint256 id, address owner, uint duration, bool updateRegistry) internal live onlyController returns (uint) {\n        require(available(id));\n        require(block.timestamp + duration + GRACE_PERIOD > block.timestamp + GRACE_PERIOD); // Prevent future overflow\n\n        expiries[id] = block.timestamp + duration;\n        if (_exists(id)) {\n            // Name was previously owned, and expired\n            _burn(id);\n        }\n        _mint(owner, id);\n        if (updateRegistry) {\n            pns.setSubnodeOwner(baseNode, bytes32(id), owner);\n        }\n\n        emit NameRegistered(id, owner, block.timestamp + duration);\n\n        return block.timestamp + duration;\n    }\n\n    function renew(uint256 id, uint duration) external override live onlyController returns (uint) {\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n        require(expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD); // Prevent future overflow\n\n        expiries[id] += duration;\n        emit NameRenewed(id, expiries[id]);\n        return expiries[id];\n    }\n\n    /**\n     * @dev Reclaim ownership of a name in PNS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external override live {\n        require(_isApprovedOrOwner(msg.sender, id));\n        pns.setSubnodeOwner(baseNode, bytes32(id), owner);\n    }\n\n    function supportsInterface(bytes4 interfaceID) public override(ERC721, IERC165, ERC721Enumerable) view returns (bool) {\n        return interfaceID == INTERFACE_META_ID || interfaceID == ERC721_ID || interfaceID == RECLAIM_ID;\n    }\n\n    /**\n     * PRIVILEGED MODULE FUNCTION. Sets a new baseURI for all token types.\n     */\n    function setURI(string memory newURI) external onlyOwner {\n        baseUri = newURI;\n    }\n\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n        string memory baseURI = baseUri;\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, Strings.toString(tokenId))) : \"\";\n    }\n\n    function getName(uint256 tokenId) public view returns (string memory) {\n        bytes32 label = bytes32(tokenId);\n        bytes32 nameHash = keccak256(abi.encodePacked(baseNode, label));\n        Resolver resolver = Resolver(pns.resolver(nameHash));\n        require(address(resolver) != address(0), \"resolver not found\");\n        string memory theName = resolver.name(nameHash);\n        return theName;\n    }\n}"
    },
    "contracts/registrar/StringUtils.sol": {
      "content": "pragma solidity >=0.8.4;\n\nlibrary StringUtils {\n    /**\n     * @dev Returns the length of a given string\n     *\n     * @param s The string to measure the length of\n     * @return The length of the input string\n     */\n    function strlen(string memory s) internal pure returns (uint) {\n        uint len;\n        uint i = 0;\n        uint bytelength = bytes(s).length;\n        for (len = 0; i < bytelength; len++) {\n            bytes1 b = bytes(s)[i];\n            if (b < 0x80) {\n                i += 1;\n            } else if (b < 0xE0) {\n                i += 2;\n            } else if (b < 0xF0) {\n                i += 3;\n            } else if (b < 0xF8) {\n                i += 4;\n            } else if (b < 0xFC) {\n                i += 5;\n            } else {\n                i += 6;\n            }\n        }\n        return len;\n    }\n\n\n    function substring(string memory s, uint startIndex, uint endIndex) internal pure returns (string memory) {\n        bytes memory strBytes = bytes(s);\n        bytes memory result = new bytes(endIndex - startIndex);\n        for (uint i = startIndex; i < endIndex; i++) {\n            result[i - startIndex] = strBytes[i];\n        }\n        return string(result);\n    }\n}\n"
    },
    "contracts/registrar/Whitelist.sol": {
      "content": "pragma solidity >=0.8.12;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Whitelist is Ownable {\n    mapping(address => bool) public whitelist;\n\n    modifier onlyWhitelisted() {\n        require(whitelist[msg.sender]);\n        _;\n    }\n\n\n    function addAddressToWhitelist(address addr) onlyOwner public returns (bool success) {\n        if (!whitelist[addr]) {\n            whitelist[addr] = true;\n            success = true;\n        }\n    }\n\n\n    function addAddressesToWhitelist(address[] calldata addrs) onlyOwner public returns (bool success) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (addAddressToWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n\n    function removeAddressFromWhitelist(address addr) onlyOwner public returns (bool success) {\n        if (whitelist[addr]) {\n            whitelist[addr] = false;\n            success = true;\n        }\n    }\n\n\n    function removeAddressesFromWhitelist(address[] calldata addrs) onlyOwner public returns (bool success) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (removeAddressFromWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n}"
    },
    "contracts/registrar/BaseRegistrar.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"../registry/PNS.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nabstract contract BaseRegistrar is Ownable, IERC721 {\n    uint constant public GRACE_PERIOD = 90 days;\n\n    event ControllerAdded(address indexed controller);\n    event ControllerRemoved(address indexed controller);\n    event NameMigrated(uint256 indexed id, address indexed owner, uint expires);\n    event NameRegistered(uint256 indexed id, address indexed owner, uint expires);\n    event NameRenewed(uint256 indexed id, uint expires);\n\n    // The PNS registry\n    PNS public pns;\n\n    // The namehash of the TLD this registrar owns (eg, .eth)\n    bytes32 public baseNode;\n\n    // A map of addresses that are authorised to register and renew names.\n    mapping(address => bool) public controllers;\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) virtual external;\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) virtual external;\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) virtual external;\n\n    // Returns the expiration timestamp of the specified label hash.\n    function nameExpires(uint256 id) virtual external view returns (uint);\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) virtual public view returns (bool);\n\n    /**\n     * @dev Register a name.\n     */\n    function register(uint256 id, address owner, uint duration) virtual external returns (uint);\n\n    function renew(uint256 id, uint duration) virtual external returns (uint);\n\n    /**\n     * @dev Reclaim ownership of a name in PNS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) virtual external;\n}\n"
    },
    "contracts/registrar/TokenURIBuilder.sol": {
      "content": "pragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/Base64.sol\";\nimport \"../resolvers/PublicResolver.sol\";\nimport \"./StringUtils.sol\";\nimport \"../registry/PNS.sol\";\nimport \"./BaseRegistrarImplementation.sol\";\n\ncontract TokenURIBuilder {\n    using StringUtils for *;\n    BaseRegistrarImplementation public nft;\n\n    constructor(BaseRegistrarImplementation _nft) {\n        nft = _nft;\n    }\n\n    function formatName(string memory name) private view returns (string memory) {\n        uint len = name.strlen();\n        if (len >= 20) {\n            string memory x = name.substring(0, 19);\n            return string(abi.encodePacked(x, '...'));\n        }\n        return name;\n    }\n\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\n        string[7] memory parts;\n        string memory name = nft.getName(tokenId);\n        string memory pnsName = string(abi.encodePacked(name, '.', nft.baseName()));\n        uint len = name.strlen();\n        string memory displayName = string(abi.encodePacked(formatName(name), '.', nft.baseName()));\n        parts[0] = '<svg version=\"1.1\"baseProfile=\"full\"width=\"500\"height=\"500\"xmlns:xlink=\"http://www.w3.org/1999/xlink\"xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"100%\"height=\"100%\"stroke-width=\"4\"fill=\"#1C1C1E\"/><defs><style class=\"style-fonts\">@font-face{font-family:\"Poppins-Bold\";src:url(data:font/ttf;base64,AAEAAAAKAIAAAwAgT1MvMtzJh5oAAACsAAAAYGNtYXAiXt6lAAABDAAAAVJnbHlmwvji+gAAAmAAAA/IaGVhZBUcA18AABIoAAAANmhoZWEIWQJzAAASYAAAACRobXR4oK0MRAAAEoQAAAEAbG9jYYW2gigAABOEAAAAgm1heHAARAAmAAAUCAAAACBuYW1leLeXhgAAFCgAAAmlcG9zdAdmBzMAAB3QAAAAogAEAoICvAAFAAACigJYAAAASwKKAlgAAAFeADIBTgAAAgAAAAAAAAAAAAAAgAcQAAAAAAAAAAAAAABJVEZPAYAALwB6BFv98wAABFsCDSAAAJMAAAAAAi0CwQAAACAABAAAAAMAAAADAAAAHAABAAAAAABMAAMAAQAAABwABAAwAAAACAAIAAIAAAA5AFoAev}</style></defs><text x=\"250\"y=\"420\"font-size=\"28\"text-anchor=\"middle\"font-family=\"Poppins-Bold\"font-style=\"Bold\"fill=\"white\">';\n        parts[1] = displayName;\n        parts[2] = '</text><image width=\"100%\"height=\"100%\"xlink:href=\"data:image/png;base64,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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAL6cq6wtLxRSNAAAAAElFTkSuQmCC\"/></svg>';\n        string memory output = string(abi.encodePacked(\n            parts[0], parts[1], parts[2]\n        ));\n        string memory json = Base64.encode(bytes(string(abi.encodePacked('{\"name\": \"', pnsName, '\", \"description\":\"', pnsName, ', an web3 domain name for pop.\", \"attributes\":[{\"trait_type\":\"Length\",\"display_type\":\"number\",\"value\": \"', Strings.toString(len), '\"},{\"trait_type\":\"Expiration Date\",\"display_type\":\"date\",\"value\":\"', Strings.toString(nft.nameExpires(tokenId)), '\"}], \"image\": \"data:image/svg+xml;base64,', Base64.encode(bytes(output)), '\"}'))));\n        output = string(abi.encodePacked('data:application/json;base64,', json));\n        return output;\n    }\n}"
    },
    "@openzeppelin/contracts/utils/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n *\n * _Available since v4.5._\n */\nlibrary Base64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // Loads the table into memory\n        string memory table = _TABLE;\n\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n        // and split into 4 numbers of 6 bits.\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n        // - `data.length + 2`  -> Round up\n        // - `/ 3`              -> Number of 3-bytes chunks\n        // - `4 *`              -> 4 characters for each chunk\n        string memory result = new string(4 * ((data.length + 2) / 3));\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 32)\n\n            // Run over the input, 3 bytes at a time\n            for {\n                let dataPtr := data\n                let endPtr := add(data, mload(data))\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 bytes (18 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F which is the number of\n                // the previous character in the ASCII table prior to the Base64 Table\n                // The result is then added to the table to get the character to write,\n                // and finally write it in the result pointer but with a left shift\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // When data `bytes` is not exactly 3 bytes long\n            // it is padded with `=` characters at the end\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n                mstore8(sub(resultPtr, 2), 0x3d)\n            }\n            case 2 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/registrar/StableLogicControl.sol": {
      "content": "pragma solidity >=0.8.4;\n\nimport \"./LogicControl.sol\";\nimport \"./SafeMath.sol\";\nimport \"./StringUtils.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n\n// StableLogicControl sets a price in USD, based on an oracle.\ncontract StableLogicControl is Ownable, LogicControl {\n    using SafeMath for *;\n    using StringUtils for *;\n\n    // Rent in base price (price by coin) units by length. Element 0 is for 1-length names, and so on.\n    uint[] public rentPrices;\n\n    mapping(string => address) public reservenames;\n\n    mapping(address => bool) public controllers;\n\n    event OracleChanged(address oracle);\n\n    event RentPriceChanged(uint[] prices);\n\n    bytes4 constant private INTERFACE_META_ID = bytes4(keccak256(\"supportsInterface(bytes4)\"));\n    bytes4 constant private ORACLE_ID = bytes4(keccak256(\"price(string,uint256,uint256)\") ^ keccak256(\"premium(string,uint256,uint256)\"));\n\n    constructor(uint[] memory _rentPrices) public {\n        setPrices(_rentPrices);\n    }\n\n    modifier authorised {\n        require(\n            msg.sender == owner() || controllers[msg.sender],\n            \"Caller is not a controller or owner\"\n        );\n        _;\n    }\n    function setController(address controller, bool enabled) public onlyOwner {\n        controllers[controller] = enabled;\n    }\n\n    function setReserveNames(string[] memory namelist, address[] memory addresslist) public authorised {\n        require(namelist.length == addresslist.length, \"array length invalid\");\n        for (uint256 i = 0; i < namelist.length; i++) {\n            reservenames[namelist[i]] = addresslist[i];\n        }\n    }\n\n    function removeReserveNames(string[] memory namelist) public authorised {\n        for (uint256 i = 0; i < namelist.length; i++) {\n            delete reservenames[namelist[i]];\n        }\n    }\n\n    function accessible(string memory name, address accessAddress) public view override returns (bool) {\n        if (accessAddress == address(this)) {\n            return true;\n        }\n        if (accessAddress == owner()) {\n            return true;\n        }\n        if (reservenames[name] != address(0) && accessAddress != reservenames[name]) {\n            return false;\n        }\n        return true;\n    }\n\n    function price(string calldata name, uint expires, uint duration) external view override returns (uint) {\n        uint len = name.strlen();\n        if (len > rentPrices.length) {\n            len = rentPrices.length;\n        }\n        require(len > 0);\n\n        uint basePrice = rentPrices[len - 1].mul(duration);\n        basePrice = basePrice.add(_premium(name, expires, duration));\n\n        return toStandardPrice(basePrice);\n    }\n\n    /**\n     * @dev Sets rent prices.\n     * @param _rentPrices The price array. Each element corresponds to a specific\n     *                    name length; names longer than the length of the array\n     *                    default to the price of the last element. Values are\n     *                    in base price units, equal to one attodollar (1e-18\n     *                    dollar) each.\n     */\n    function setPrices(uint[] memory _rentPrices) public onlyOwner {\n        rentPrices = _rentPrices;\n        emit RentPriceChanged(_rentPrices);\n    }\n\n    /**\n     * @dev Returns the pricing premium in wei.\n     */\n    function premium(string calldata name, uint expires, uint duration) external view returns (uint) {\n        return toStandardPrice(_premium(name, expires, duration));\n    }\n\n    /**\n     * @dev Returns the pricing premium in internal base units.\n     */\n    function _premium(string memory name, uint expires, uint duration) virtual internal view returns (uint) {\n        return 0;\n    }\n\n    function toStandardPrice(uint amount) internal view returns (uint) {\n        return amount; // wei\n    }\n\n    function supportsInterface(bytes4 interfaceID) public view virtual returns (bool) {\n        return interfaceID == INTERFACE_META_ID || interfaceID == ORACLE_ID;\n    }\n}\n"
    },
    "contracts/registrar/LogicControl.sol": {
      "content": "pragma solidity >=0.8.4;\n\ninterface LogicControl {\n    /**\n     * @dev Returns the price to register or renew a name.\n     * @param name The name being registered or renewed.\n     * @param expires When the name presently expires (0 if this is a new registration).\n     * @param duration How long the name is being registered or extended for, in seconds.\n     * @return The price of this renewal or registration, in wei.\n     */\n    function price(string calldata name, uint expires, uint duration) external view returns (uint);\n\n    function accessible(string memory name, address owner) external view returns (bool);\n}\n"
    },
    "contracts/registrar/SafeMath.sol": {
      "content": "pragma solidity >=0.8.4;\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n    * @dev Multiplies two unsigned integers, reverts on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two unsigned integers, reverts on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n"
    },
    "contracts/registrar/LinearPremiumPriceOracle.sol": {
      "content": "pragma solidity >=0.8.4;\n\nimport \"./SafeMath.sol\";\nimport \"./StableLogicControl.sol\";\n\ncontract LinearPremiumLogicControl is StableLogicControl {\n    using SafeMath for *;\n\n    uint GRACE_PERIOD = 90 days;\n\n    uint public initialPremium;\n    uint public premiumDecreaseRate;\n\n    bytes4 constant private TIME_UNTIL_PREMIUM_ID = bytes4(keccak256(\"timeUntilPremium(uint,uint\"));\n\n    constructor(uint[] memory _rentPrices, uint _initialPremium, uint _premiumDecreaseRate) public\n    StableLogicControl(_rentPrices)\n    {\n        initialPremium = _initialPremium;\n        premiumDecreaseRate = _premiumDecreaseRate;\n    }\n\n    function _premium(string memory name, uint expires, uint /*duration*/) override internal view returns (uint) {\n        expires = expires.add(GRACE_PERIOD);\n        if (expires > block.timestamp) {\n            // No premium for renewals\n            return 0;\n        }\n\n        // Calculate the discount off the maximum premium\n        uint discount = premiumDecreaseRate.mul(block.timestamp.sub(expires));\n\n        // If we've run out the premium period, return 0.\n        if (discount > initialPremium) {\n            return 0;\n        }\n\n        return initialPremium - discount;\n    }\n\n    /**\n     * @dev Returns the timestamp at which a name with the specified expiry date will have\n     *      the specified re-registration price premium.\n     * @param expires The timestamp at which the name expires.\n     * @param amount The amount, in wei, the caller is willing to pay\n     * @return The timestamp at which the premium for this domain will be `amount`.\n     */\n    function timeUntilPremium(uint expires, uint amount) external view returns (uint) {\n        // amount = weiToAttoUSD(amount);\n        // require(amount <= initialPremium);\n\n        // expires = expires.add(GRACE_PERIOD);\n\n        uint discount = initialPremium.sub(amount);\n        uint duration = discount.div(premiumDecreaseRate);\n        return expires.add(duration);\n    }\n\n    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {\n        return (interfaceID == TIME_UNTIL_PREMIUM_ID) || super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/registrar/RegistrarControllerV1.sol": {
      "content": "pragma solidity >=0.8.12;\n\nimport \"./BaseRegistrarImplementation.sol\";\nimport \"./StringUtils.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\n\n/**\n * @dev A registrar controller for registering and renewing names at fixed cost.\n */\ncontract RegistrarControllerV1 is Ownable {\n    using StringUtils for *;\n    uint256 public constant MIN_REGISTRATION_DURATION = 365 days;\n    BaseRegistrarImplementation base;\n    constructor (\n        BaseRegistrarImplementation _base,\n        uint _basePrice\n    ) {\n        base = _base;\n        basePrice = _basePrice;\n    }\n\n    uint public basePrice;\n\n    event NameRegistered(\n        string name,\n        bytes32 indexed label,\n        address indexed owner,\n        uint256 cost,\n        uint256 expires\n    );\n    event NameRenewed(\n        string name,\n        bytes32 indexed label,\n        uint256 cost,\n        uint256 expires\n    );\n\n    bytes32 public root;\n\n    function register(\n        string memory name,\n        address owner,\n        uint256 duration,\n        address resolver\n    ) public payable onlyOwner {\n        bytes32 label = keccak256(bytes(name));\n        uint256 tokenId = uint256(label);\n\n        uint256 cost = rentPrice(name, duration);\n\n        _registerSingleDomain(\n            name, owner, duration, resolver, tokenId,\n            label, cost, base\n        );\n\n        // Refund any extra payment\n        if (msg.value > cost) {\n            payable(msg.sender).transfer(msg.value - cost);\n        }\n    }\n\n    function _registerSingleDomain(\n        string memory name,\n        address owner,\n        uint256 duration,\n        address resolver,\n        uint tokenId,\n        bytes32 label,\n        uint cost,\n        BaseRegistrarImplementation registrar\n    ) internal {\n        // The nodehash of this label\n        bytes32 nodehash = keccak256(abi.encodePacked(registrar.baseNode(), label));\n\n        // Set this contract as the (temporary) owner, giving it\n        uint256 expires;\n        // permission to set up the resolver.\n        expires = registrar.register(tokenId, address(this), duration);\n\n        // Set the resolver\n        registrar.pns().setResolver(nodehash, resolver);\n\n        // Configure the resolver\n        Resolver(resolver).setAddr(nodehash, owner);\n        Resolver(resolver).setName(nodehash, name);\n\n        // Now transfer full ownership to the expeceted owner\n        registrar.reclaim(tokenId, owner);\n        registrar.transferFrom(address(this), owner, tokenId);\n        emit NameRegistered(name, label, owner, cost, expires);\n    }\n\n    function renew(\n        string calldata name,\n        uint256 duration\n    ) external payable {\n        uint256 cost = rentPrice(name, duration);\n        require(msg.value >= cost);\n\n        bytes32 label = keccak256(bytes(name));\n        uint256 expires = base.renew(uint256(label), duration);\n        emit NameRenewed(name, label, cost, expires);\n\n        if (msg.value > cost) {\n            payable(msg.sender).transfer(msg.value - cost);\n        }\n    }\n\n    function withdraw() public onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function setBasePrice(uint _price) public onlyOwner {\n        basePrice = _price;\n    }\n\n    function rentPrice(\n        string memory name,\n        uint256 duration\n    ) public view returns (uint256){\n        // no need to check basePrice\n        // require(basePrice > 0, \"configuration incorrect\");\n        uint price = basePrice * duration;\n        return price;\n    }\n\n    function valid(string memory name) public view returns (bool) {\n        if (name.strlen() < 1) {\n            return false;\n        }\n        bytes memory nb = bytes(name);\n        // zero width for /u200b /u200c /u200d and U+FEFF\n\n        for (uint256 i; i < nb.length; i++) {\n            bytes1 char = nb[i];\n            if (char >= 0x41 && char <= 0x5A) {\n                return false; //A-Z\n            }\n        }\n        // zero width\n        if (nb.length >= 2) {\n            for (uint256 i; i < nb.length - 2; i++) {\n                if (bytes1(nb[i]) == 0xe2 && bytes1(nb[i + 1]) == 0x80) {\n                    if (\n                        bytes1(nb[i + 2]) == 0x8b ||\n                        bytes1(nb[i + 2]) == 0x8c ||\n                        bytes1(nb[i + 2]) == 0x8d\n                    ) {\n                        return false;\n                    }\n                } else if (bytes1(nb[i]) == 0xef) {\n                    if (bytes1(nb[i + 1]) == 0xbb && bytes1(nb[i + 2]) == 0xbf)\n                        return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    function available(string memory name) public view returns (bool) {\n        bytes32 label = keccak256(bytes(name));\n        bool _available = true;\n        if (!base.available(uint256(label))) {\n            _available = false;\n        }\n        return valid(name) && _available;\n    }\n\n    function withdraw(address receiver) public onlyOwner {\n        payable(receiver).transfer(address(this).balance);\n    }\n}\n"
    },
    "contracts/registrar/IBatchRegistrarController.sol": {
      "content": "pragma solidity >=0.8.4;\n\nimport \"./BaseRegistrarImplementation.sol\";\n\ninterface IETHBatchRegistrarController {\n    function rentPrice(string memory, uint256, BaseRegistrarImplementation[] calldata)\n        external\n        returns (uint256);\n\n    function available(string memory, BaseRegistrarImplementation[] calldata) external returns (bool);\n\n    function makeCommitment(\n        string memory,\n        address,\n        bytes32,\n        address\n    ) external returns (bytes32);\n\n    function commit(bytes32) external;\n\n    function register(\n        string calldata,\n        address,\n        uint256,\n        bytes32,\n        address,\n        BaseRegistrarImplementation[] calldata\n    ) external payable;\n\n    function renew(string calldata, uint256, BaseRegistrarImplementation[] calldata) external payable;\n}\n"
    },
    "contracts/registry/PNSRegistry.sol": {
      "content": "pragma solidity >=0.8.4;\n\nimport \"./PNS.sol\";\n\n/**\n * The PNS registry contract.\n */\ncontract PNSRegistry is PNS {\n\n    struct Record {\n        address owner;\n        address resolver;\n        uint64 ttl;\n    }\n\n    mapping(bytes32 => Record) records;\n    mapping(address => mapping(address => bool)) operators;\n\n    // Permits modifications only by the owner of the specified node.\n    modifier authorised(bytes32 node) {\n        address owner = records[node].owner;\n        require(owner == msg.sender || operators[owner][msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Constructs a new PNS registrar.\n     */\n    constructor() public {\n        records[0x0].owner = msg.sender;\n    }\n\n    /**\n     * @dev Sets the record for a node.\n     * @param node The node to update.\n     * @param owner The address of the new owner.\n     * @param resolver The address of the resolver.\n     * @param ttl The TTL in seconds.\n     */\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external virtual override {\n        setOwner(node, owner);\n        _setResolverAndTTL(node, resolver, ttl);\n    }\n\n    /**\n     * @dev Sets the record for a subnode.\n     * @param node The parent node.\n     * @param label The hash of the label specifying the subnode.\n     * @param owner The address of the new owner.\n     * @param resolver The address of the resolver.\n     * @param ttl The TTL in seconds.\n     */\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external virtual override {\n        bytes32 subnode = setSubnodeOwner(node, label, owner);\n        _setResolverAndTTL(subnode, resolver, ttl);\n    }\n\n    /**\n     * @dev Transfers ownership of a node to a new address. May only be called by the current owner of the node.\n     * @param node The node to transfer ownership of.\n     * @param owner The address of the new owner.\n     */\n    function setOwner(bytes32 node, address owner) public virtual override authorised(node) {\n        _setOwner(node, owner);\n        emit Transfer(node, owner);\n    }\n\n    /**\n     * @dev Transfers ownership of a subnode keccak256(node, label) to a new address. May only be called by the owner of the parent node.\n     * @param node The parent node.\n     * @param label The hash of the label specifying the subnode.\n     * @param owner The address of the new owner.\n     */\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public virtual override authorised(node) returns (bytes32) {\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\n        _setOwner(subnode, owner);\n        emit NewOwner(node, label, owner);\n        return subnode;\n    }\n\n    /**\n     * @dev Sets the resolver address for the specified node.\n     * @param node The node to update.\n     * @param resolver The address of the resolver.\n     */\n    function setResolver(bytes32 node, address resolver) public virtual override authorised(node) {\n        emit NewResolver(node, resolver);\n        records[node].resolver = resolver;\n    }\n\n    /**\n     * @dev Sets the TTL for the specified node.\n     * @param node The node to update.\n     * @param ttl The TTL in seconds.\n     */\n    function setTTL(bytes32 node, uint64 ttl) public virtual override authorised(node) {\n        emit NewTTL(node, ttl);\n        records[node].ttl = ttl;\n    }\n\n    /**\n     * @dev Enable or disable approval for a third party (\"operator\") to manage\n     *  all of `msg.sender`'s PNS records. Emits the ApprovalForAll event.\n     * @param operator Address to add to the set of authorized operators.\n     * @param approved True if the operator is approved, false to revoke approval.\n     */\n    function setApprovalForAll(address operator, bool approved) external virtual override {\n        operators[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n     * @dev Returns the address that owns the specified node.\n     * @param node The specified node.\n     * @return address of the owner.\n     */\n    function owner(bytes32 node) public virtual override view returns (address) {\n        address addr = records[node].owner;\n        if (addr == address(this)) {\n            return address(0x0);\n        }\n\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address of the resolver for the specified node.\n     * @param node The specified node.\n     * @return address of the resolver.\n     */\n    function resolver(bytes32 node) public virtual override view returns (address) {\n        return records[node].resolver;\n    }\n\n    /**\n     * @dev Returns the TTL of a node, and any records associated with it.\n     * @param node The specified node.\n     * @return ttl of the node.\n     */\n    function ttl(bytes32 node) public virtual override view returns (uint64) {\n        return records[node].ttl;\n    }\n\n    /**\n     * @dev Returns whether a record has been imported to the registry.\n     * @param node The specified node.\n     * @return Bool if record exists\n     */\n    function recordExists(bytes32 node) public virtual override view returns (bool) {\n        return records[node].owner != address(0x0);\n    }\n\n    /**\n     * @dev Query if an address is an authorized operator for another address.\n     * @param owner The address that owns the records.\n     * @param operator The address that acts on behalf of the owner.\n     * @return True if `operator` is an approved operator for `owner`, false otherwise.\n     */\n    function isApprovedForAll(address owner, address operator) external virtual override view returns (bool) {\n        return operators[owner][operator];\n    }\n\n    function _setOwner(bytes32 node, address owner) internal virtual {\n        records[node].owner = owner;\n    }\n\n    function _setResolverAndTTL(bytes32 node, address resolver, uint64 ttl) internal {\n        if (resolver != records[node].resolver) {\n            records[node].resolver = resolver;\n            emit NewResolver(node, resolver);\n        }\n\n        if (ttl != records[node].ttl) {\n            records[node].ttl = ttl;\n            emit NewTTL(node, ttl);\n        }\n    }\n}\n"
    },
    "contracts/registrar/BaseRegistrarImplementationUpgradeable.sol": {
      "content": "//pragma solidity >=0.8.4;\n//\n//import \"../registry/PNS.sol\";\n//import \"./BaseRegistrar.sol\";\n//import {ERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\n//import {ERC721EnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\n//import {ERC721URIStorageUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\";\n//import {ERC721BurnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\n//import {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\n//import {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n//import \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n//\n//contract BaseRegistrarImplementationUpgradeable is OwnableUpgradeable, ERC721Upgradeable, ERC721EnumerableUpgradeable, ERC721URIStorageUpgradeable, ERC721BurnableUpgradeable, BaseRegistrar {\n//    // A map of expiry times\n//    mapping(uint256 => uint) expiries;\n//\n//    bytes4 constant private INTERFACE_META_ID = bytes4(keccak256(\"supportsInterface(bytes4)\"));\n//    bytes4 constant private ERC721_ID = bytes4(\n//        keccak256(\"balanceOf(address)\") ^\n//        keccak256(\"ownerOf(uint256)\") ^\n//        keccak256(\"approve(address,uint256)\") ^\n//        keccak256(\"getApproved(uint256)\") ^\n//        keccak256(\"setApprovalForAll(address,bool)\") ^\n//        keccak256(\"isApprovedForAll(address,address)\") ^\n//        keccak256(\"transferFrom(address,address,uint256)\") ^\n//        keccak256(\"safeTransferFrom(address,address,uint256)\") ^\n//        keccak256(\"safeTransferFrom(address,address,uint256,bytes)\")\n//    );\n//    bytes4 constant private RECLAIM_ID = bytes4(keccak256(\"reclaim(uint256,address)\"));\n//\n//    string public _baseTokenURI;\n//\n//    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view override returns (bool) {\n//        address owner = ownerOf(tokenId);\n//        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n//    }\n//\n//    function __BaseRegistrarImplementation_i(PNS _pns, bytes32 _baseNode) initializer public {\n//        __ERC721_init(\"POP Name Service\", \"PNS\");\n//        __ERC721Enumerable_init();\n//        __ERC721URIStorage_init();\n//        __ERC721Burnable_init();\n//        __Ownable_init();\n//        __BaseRegistrarImplementation_init(_pns, _baseNode);\n//    }\n//\n//    function __BaseRegistrarImplementation_init(PNS _pns, bytes32 _baseNode) internal onlyInitializing {\n//        __BaseRegistrarImplementation_init_unchained(_pns, _baseNode);\n//    }\n//\n//    function __BaseRegistrarImplementation_init_unchained(PNS _pns, bytes32 _baseNode) internal onlyInitializing {\n//        pns = _pns;\n//        baseNode = _baseNode;\n//    }\n//\n//    function _baseURI() internal view virtual override returns (string memory) {\n//        return _baseTokenURI; //\"ipfs://mehu4wWNM/\"\n//    }\n//\n//    function setBaseURI(string calldata baseURI) external onlyOwner {\n//        _baseTokenURI = baseURI;\n//    }\n//\n//    modifier live {\n//        require(pns.owner(baseNode) == address(this));\n//        _;\n//    }\n//\n//    modifier onlyController {\n//        require(controllers[msg.sender]);\n//        _;\n//    }\n//\n//    /**\n//     * @dev Gets the owner of the specified token ID. Names become unowned\n//      *      when their registration expires.\n//      * @param tokenId uint256 ID of the token to query the owner of\n//      * @return address currently marked as the owner of the given token ID\n//      */\n//    function ownerOf(uint256 tokenId) public view override(IERC721, ERC721Upgradeable) returns (address) {\n//        require(expiries[tokenId] > block.timestamp);\n//        return super.ownerOf(tokenId);\n//    }\n//\n//    // Authorises a controller, who can register and renew domains.\n//    function addController(address controller) external override onlyOwner {\n//        controllers[controller] = true;\n//        emit ControllerAdded(controller);\n//    }\n//\n//    // Revoke controller permission for an address.\n//    function removeController(address controller) external override onlyOwner {\n//        controllers[controller] = false;\n//        emit ControllerRemoved(controller);\n//    }\n//\n//    // Set the resolver for the TLD this registrar manages.\n//    function setResolver(address resolver) external override onlyOwner {\n//        pns.setResolver(baseNode, resolver);\n//    }\n//\n//    // Returns the expiration timestamp of the specified id.\n//    function nameExpires(uint256 id) external view override returns (uint) {\n//        return expiries[id];\n//    }\n//\n//    // Returns true iff the specified name is available for registration.\n//    function available(uint256 id) public view override returns (bool) {\n//        // Not available if it's registered here or in its grace period.\n//        return expiries[id] + GRACE_PERIOD < block.timestamp;\n//    }\n//\n//    /**\n//     * @dev Register a name.\n//      * @param id The token ID (keccak256 of the label).\n//      * @param owner The address that should own the registration.\n//      * @param duration Duration in seconds for the registration.\n//      */\n//    function register(uint256 id, address owner, uint duration) external override returns (uint) {\n//        return _register(id, owner, duration, true);\n//    }\n//\n//    /**\n//     * @dev Register a name, without modifying the registry.\n//      * @param id The token ID (keccak256 of the label).\n//      * @param owner The address that should own the registration.\n//      * @param duration Duration in seconds for the registration.\n//      */\n//    function registerOnly(uint256 id, address owner, uint duration) external returns (uint) {\n//        return _register(id, owner, duration, false);\n//    }\n//\n//    function _register(uint256 id, address owner, uint duration, bool updateRegistry) internal live onlyController returns (uint) {\n//        require(available(id));\n//        require(block.timestamp + duration + GRACE_PERIOD > block.timestamp + GRACE_PERIOD); // Prevent future overflow\n//\n//        expiries[id] = block.timestamp + duration;\n//        if (_exists(id)) {\n//            // Name was previously owned, and expired\n//            _burn(id);\n//        }\n//        _mint(owner, id);\n//        if (updateRegistry) {\n//            pns.setSubnodeOwner(baseNode, bytes32(id), owner);\n//        }\n//\n//        emit NameRegistered(id, owner, block.timestamp + duration);\n//\n//        return block.timestamp + duration;\n//    }\n//\n//    function renew(uint256 id, uint duration) external override live onlyController returns (uint) {\n//        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n//        require(expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD); // Prevent future overflow\n//\n//        expiries[id] += duration;\n//        emit NameRenewed(id, expiries[id]);\n//        return expiries[id];\n//    }\n//\n//    /**\n//     * @dev Reclaim ownership of a name in pns, if you own it in the registrar.\n//      */\n//    function reclaim(uint256 id, address owner) external override live {\n//        require(_isApprovedOrOwner(msg.sender, id));\n//        pns.setSubnodeOwner(baseNode, bytes32(id), owner);\n//    }\n//\n//    function supportsInterface(bytes4 interfaceID) public override(IERC165, ERC721Upgradeable, ERC721EnumerableUpgradeable) view returns (bool) {\n//        return interfaceID == INTERFACE_META_ID ||\n//        interfaceID == ERC721_ID ||\n//        interfaceID == RECLAIM_ID || super.supportsInterface(interfaceID);\n//        // return interfaceId == type(IERC721EnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n//    }\n//\n//\n//    function _burn(uint256 tokenId) internal override(ERC721Upgradeable, ERC721URIStorageUpgradeable) {\n//        super._burn(tokenId);\n//    }\n//\n//    function tokenURI(uint256 tokenId) public view override(ERC721Upgradeable, ERC721URIStorageUpgradeable) returns (string memory){\n//        return super.tokenURI(tokenId);\n//    }\n//\n//}"
    },
    "contracts/registrar/DummyOracle.sol": {
      "content": "pragma solidity >=0.8.4;\n\ncontract DummyOracle {\n    int value;\n\n    constructor(int _value) public {\n        set(_value);\n    }\n\n    function set(int _value) public {\n        value = _value;\n    }\n\n    function latestAnswer() public view returns(int256) {\n        return value;\n    }\n}\n"
    },
    "contracts/registrar/IRegistrarController.sol": {
      "content": "pragma solidity >=0.8.4;\n\ninterface IRegistrarController {\n    function rentPrice(string memory, uint256)\n        external\n        returns (uint256);\n\n    function available(string memory) external returns (bool);\n\n    function makeCommitment(\n        string memory,\n        address,\n        bytes32,\n        address,\n        bool\n    ) external returns (bytes32);\n\n    function commit(bytes32) external;\n\n    function register(\n        string calldata,\n        address,\n        uint256,\n        bytes32,\n        address,\n        bool\n    ) external payable;\n\n    function renew(string calldata, uint256) external payable;\n}\n"
    },
    "contracts/registrar/TestResolver.sol": {
      "content": "pragma solidity >=0.8.4;\n\n/**\n * @dev A test resolver implementation\n */\ncontract TestResolver {\n    mapping(bytes32 => address) addresses;\n\n    constructor() public {\n    }\n\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\n        return interfaceID == 0x01ffc9a7 || interfaceID == 0x3b3b57de;\n    }\n\n    function addr(bytes32 node) public view returns (address) {\n        return addresses[node];\n    }\n\n    function setAddr(bytes32 node, address addr) public {\n        addresses[node] = addr;\n    }\n}\n"
    },
    "contracts/root/Ownable.sol": {
      "content": "pragma solidity ^0.8.4;\n\ncontract Ownable {\n\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    modifier onlyOwner {\n        require(isOwner(msg.sender));\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function isOwner(address addr) public view returns (bool) {\n        return owner == addr;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}